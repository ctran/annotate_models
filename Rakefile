# Note : this causes annoying psych warnings under Ruby 1.9.2-p180; to fix, upgrade to 1.9.3
begin
  require 'bundler'
  Bundler.setup(:default, :development)
rescue Bundler::BundlerError => e
  $stderr.puts e.message
  $stderr.puts "Run `bundle install` to install missing gems"
  exit e.status_code
end

using_dsl = false
begin
  require 'rake/dsl_definition'
  using_dsl = true
rescue Exception => e
  # We might just be on an old version of Rake...
end
require 'rake'
if(using_dsl)
  include Rake::DSL
end

require "./lib/annotate"

require 'mg'
MG.new("annotate.gemspec")

require "rspec/core/rake_task" # RSpec 2.0
RSpec::Core::RakeTask.new(:spec) do |t|
  t.pattern = ['spec/*_spec.rb', 'spec/**/*_spec.rb']
  t.rspec_opts = ['--backtrace', '--format d']
end

# Placeholder for running bin/* in development...
task :environment

task :integration_environment do
  require './spec/spec_helper'
end

namespace :gemsets do
  desc "Completely empty any gemsets used by scenarios, so they'll be perfectly clean on the next run."
  task :empty => [:integration_environment] do
    Annotate::Integration::SCENARIOS.each do |test_rig, base_dir, test_name|
      Annotate::Integration.empty_gemset(test_rig)
    end
  end
end
task :clobber => :'gemsets:empty'

namespace :integration do
  desc "Remove any cruft generated by manual debugging runs which is .gitignore'd."
  task :clean => :integration_environment do
    Annotate::Integration.nuke_all_cruft
  end

  desc "Reset any changed files, and remove any untracked files in spec/integration/*/, plus run integration:clean."
  task :clobber => [:integration_environment, :'integration:clean'] do
    Annotate::Integration.reset_dirty_files
    Annotate::Integration.clear_untracked_files
  end

  task :symlink => [:integration_environment] do
    require 'digest/md5'

    integration_dir = File.expand_path(File.join(File.dirname(__FILE__), 'spec', 'integration'))
    fixture_dir = File.expand_path(File.join(File.dirname(__FILE__), 'spec', 'fixtures'))
    target_dir = File.expand_path(ENV['TARGET']) if(ENV['TARGET'])
    raise "Must specify TARGET=x, where x is an integration test scenario!" unless(target_dir && Dir.exist?(target_dir))
    raise "TARGET directory must be within spec/integration/!" unless(target_dir.start_with?(integration_dir))
    candidates = {}
    FileList[
      "#{target_dir}/.rvmrc",
      "#{target_dir}/**/*"
    ].select { |fname| !(File.symlink?(fname) || File.directory?(fname)) }.
      map { |fname| fname.sub(integration_dir, '') }.
      reject do |fname|
        fname =~ /\/\.gitkeep$/ ||
        fname =~ /\/app\/models\// ||
        fname =~ /\/routes\.rb$/ ||
        fname =~ /\/fixtures\// ||
        fname =~ /\/factories\// ||
        fname =~ /\.sqlite3$/ ||
        (fname =~ /\/test\// && fname !~ /_helper\.rb$/) ||
        (fname =~ /\/spec\// && fname !~ /_helper\.rb$/)
      end.
      map { |fname| "#{integration_dir}#{fname}"}.
      each do |fname|
        digest = Digest::MD5.hexdigest(File.read(fname))
        candidates[digest] ||= []
        candidates[digest] << fname
      end
    fixtures = {}
    FileList["spec/fixtures/**/*"].each do |fname|
      fixtures[Digest::MD5.hexdigest(File.read(fname))] = File.expand_path(fname)
    end

    candidates.keys.each do |digest|
      if(fixtures.has_key?(digest))
        candidates[digest].each do |fname|
          # Double-check contents in case of hash collision...
          if(FileUtils.identical?(fname, fixtures[digest]))
            destination_dir = Pathname.new(File.dirname(fname))
            relative_target = Pathname.new(fixtures[digest]).relative_path_from(destination_dir)
            Dir.chdir(destination_dir) do
              sh("ln", "-sfn", relative_target.to_s, File.basename(fname))
            end
          end
        end
      end
    end
  end
end
task :clobber => :'integration:clobber'

require 'yard'
YARD::Rake::YardocTask.new do |t|
  # t.files   = ['features/**/*.feature', 'features/**/*.rb', 'lib/**/*.rb']
  # t.options = ['--any', '--extra', '--opts'] # optional
end

namespace :yard do
  task :clobber do
    FileUtils.rm_f(".yardoc")
    FileUtils.rm_f("doc")
  end
end
task :clobber => :'yard:clobber'

namespace :rubinius do
  task :clobber do
    FileList["**/*.rbc"].each { |fname| FileUtils.rm_f(fname) }
    FileList[".rbx/**/*"].each { |fname| FileUtils.rm_f(fname) }
  end
end
task :clobber => :'rubinius:clobber'

# want other tests/tasks run by default? Add them to the list
task :default => [:spec]
